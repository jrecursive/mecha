
// 
// register mecha.vm.bifs.* system verbs
// 

register namespace:$ module-class:mecha.vm.bifs.RiakClientModule verbs:(get:Get put:Put delete:Delete)
register namespace:$ module-class:mecha.vm.bifs.ChannelModule verbs:(subscribe:Subscribe unsubscribe:Unsubscribe publish:Publish)
register namespace:$ module-class:mecha.vm.bifs.ClientModule verbs:(client-sink:ClientSink channel-sink:ChannelSink start-all-sources:StartAllSources macro-sink:MacroSink)
register namespace:$ module-class:mecha.vm.bifs.SolrModule verbs:(solr-select:Select solr-select-iterator:SelectIterator value-count-reducer:ValueCountReducer covered-index-select:CoveredIndexSelect solr-commit:SolrCommit cardinality-reducer:CardinalityReducer)
register namespace:$ module-class:mecha.vm.bifs.MDBModule verbs:(materialize-pbk-stream:MaterializePBKStream stream-partition-bucket:StreamPartitionBucket partition-bucket-iterator:PartitionBucketIterator drop-partition-bucket:DropPartitionBucket global-drop-bucket:GlobalDropBucket)
register namespace:$ module-class:mecha.vm.bifs.ETLModule verbs:(project:Project extract-riak-value:ExtractRiakValue)
register namespace:$ module-class:mecha.vm.bifs.ClusterModule verbs:(with-coverage:WithCoverage with-iterated-coverage:WithIteratedCoverage with-sorted-coverage:WithSortedCoverage warp:Warp with-cluster-coverage:WithClusterCoverage)
register namespace:$ module-class:mecha.vm.bifs.StreamModule verbs:(vector-sequencer:VectorSequencer eat:Eat limit:Limit)
register namespace:$ module-class:mecha.vm.bifs.RelationalModule verbs:(sort-merge-equijoin:SortMergeEquiJoin)
register namespace:$ module-class:mecha.vm.bifs.IteratorModule verbs:(buffered-iterator:BufferedIterator)

/////////////
// globals //
/////////////

//
// spatial-query
//

#define-global spatial-query
#if ($args.filter && $args.filter != "") 
	#set ($args.logical-connector = "AND") 
#else #set ($args.logical-connector = "") #end
#if (!$args.filter) #set ($args.filter = "") #end
#if (!$args.materialize) #set ($args.materialize = "true") #end
#if (!$args.sort-field) #set ($args.sort-field = "key") #end
#if (!$args.sort-dir) #set ($args.sort-dir = "asc") #end

${root} = (covered-index-select sort-field:${args.sort-field} sort-order:${args.sort-dir} query-marker:"<<${guid}-q>>" host-marker:"<<${guid}-h>>" bucket:${args.bucket} do:(warp host:<<${guid}-h>> do:(solr-select-iterator params:(q:"((<<${guid}-q>>) AND bucket:${args.bucket}) ${args.logical-connector} ${args.filter}" sfield:${args.field} pt:"${args.lat},${args.lon}" d:${args.radius} fq:"{!bbox}" sort:"${args.sort-field} ${args.sort-dir}") materialize:${args.materialize})))
${root} -> ${sink}

#end spatial-query

//
// facet
//

#define-global facet
#if ($args.filter && $args.filter != "") 
	#set ($args.logical-connector = "AND") 
#else #set ($args.logical-connector = "") #end
#if (!$args.filter) #set ($args.filter = "") #end

#if (!$args.mincount) #set ($args.mincount = "1") #end
#if (!$args.limit) #set ($args.limit = "100") #end
#if (!$args.start) #set ($args.start = "0") #end
#if (!$args.sort) #set ($args.sort = "count") #end

#if ($args.prefix) #set ($prefix_arg = "facet.prefix:${args.prefix}")
#else #set ($prefix_arg = "") #end

#if (!$args.cardinality-only) #set ($args.cardinality-only = "false") #end

${root} = (with-coverage partition-marker:"<<${guid}-p>>" host-marker:"<<${guid}-h>>" bucket:${args.bucket} do:(warp host:<<${guid}-h>> do:(solr-select params:(facet:true facet.limit:${args.limit} facet.field:${args.field} facet.mincount:${args.mincount} facet.offset:${args.start} $prefix_arg facet.sort:${args.sort} rows:0 q:"(partition:<<${guid}-p>> AND bucket:${args.bucket}) ${args.logical-connector} ${args.filter}") cardinality-only:${args.cardinality-only} partition:<<${guid}-p>>)))

#if ($args.cardinality-only == "true")
${guid}-reducer = (cardinality-reducer)
#else
${guid}-reducer = (value-count-reducer)
#end

${root} -> ${guid}-reducer
${guid}-reducer -> ${sink}
#end facet

// 
// cardinality
//

#define-global cardinality
#if (!$args.filter) #set ($args.filter = "") #end
${root} = (#facet bucket:${args.bucket} field:${args.field} filter:"${args.filter}" start:0 limit:-1 sort:index cardinality-only:true)
${root} -> ${sink}
#end cardinality

//
// count
//

#define-global count
#if (!$args.filter) #set ($args.filter = "") #end
${root} = (with-coverage partition-marker:"<<${guid}-p>>" host-marker:"<<${guid}-h>>" bucket:${args.bucket} do:(warp host:<<${guid}-h>> do:(solr-select params:(q:"partition:<<${guid}-p>> AND bucket:${args.bucket} ${args.filter}") count-only:true)))
${guid}-reducer = (value-count-reducer)
${root} -> ${guid}-reducer
${guid}-reducer -> ${sink}
#end count

//
// drop-bucket
//
#define-global drop-bucket
#if ($args.bucket)
${root} = (with-cluster-coverage host-marker:"<<${guid}-h>>" do:(warp host:<<${guid}-h>> do:(global-drop-bucket bucket:${args.bucket})))
${guid}-reducer = (value-count-reducer)
${root} -> ${guid}-reducer
${guid}-reducer -> ${sink}
#end
#end drop-bucket

//
// query
//

#define-global query
#if (!$args.start) #set ($args.start = "0") #end
#if (!$args.count) #set ($args.count = "10") #end
#if (!$args.filter) #set ($args.filter = "") #end
#if (!$args.sort-field) #set ($args.sort-field = "key") #end
#if (!$args.sort-dir) #set ($args.sort-dir = "asc") #end
#if (!$args.materialize) #set ($args.materialize = "true") #end
#if (!$args.external-iterator) #set ($args.external-iterator = "false") #end
${root} = (with-sorted-coverage sort-field:${args.sort-field} sort-order:${args.sort-dir} partition-marker:"<<${guid}-p>>" host-marker:"<<${guid}-h>>" bucket:${args.bucket} do:(warp host:<<${guid}-h>> do:(solr-select-iterator params:(q:"*:*" fq:"partition:<<${guid}-p>> AND bucket:${args.bucket} ${args.filter}" rows:${args.count} sort:"${args.sort-field} ${args.sort-dir}") materialize:${args.materialize} external-iterator:${args.external-iterator})))
${guid}-start = (eat count:${args.start})
${guid}-limit = (limit count:${args.count})
${root} -> ${guid}-start
${guid}-start -> ${guid}-limit
${guid}-limit -> ${sink}
#end query

//
// select
//  (host-optimized version of 'query')
//

#define-global select
#*
    Setup parameter default values.
*#

#if (!$args.start) #set ($args.start = "0") #end
#if (!$args.count) #set ($args.count = "-1") #end
#if (!$args.sort-field) #set ($args.sort-field = "key") #end
#if (!$args.sort-dir) #set ($args.sort-dir = "asc") #end
#if (!$args.materialize) #set ($args.materialize = "true") #end

#*
    If a filter is specified, generate the logical AND
    connector.
*#

#if ($args.filter && $args.filter != "") 
	#set ($args.logical-connector = "AND") 
#else #set ($args.logical-connector = "") #end
#if (!$args.filter) #set ($args.filter = "") #end

#*
    Generate the chain of:
        covered-index-select do:
            warp <host> do: 
                solr-select-iterator
*#

${root} = (covered-index-select sort-field:${args.sort-field} sort-order:${args.sort-dir} query-marker:"<<${guid}-q>>" host-marker:"<<${guid}-h>>" bucket:${args.bucket} do:(warp host:<<${guid}-h>> do:(solr-select-iterator params:(q:"*:*" fq:"((<<${guid}-q>>) AND bucket:${args.bucket}) ${args.logical-connector} ${args.filter}" rows:${args.count} sort:"${args.sort-field} ${args.sort-dir}") materialize:${args.materialize})))

#*
    Account for start & count (e.g., LIMIT <start>,<count>) globally.
*#

#set ($connecting_vertex = $root)

#if ($args.start != "0")
${guid}-start = (eat count:${args.start})
${connecting_vertex} -> ${guid}-start
#set ($connecting_vertex = "${guid}-start")
#end

#if ($args.count != "-1")
${guid}-limit = (limit count:${args.count})
${connecting_vertex} -> ${guid}-limit
#set ($connecting_vertex = "${guid}-limit")
#end

${connecting_vertex} -> ${sink}
#end select

//
// cluster-wide commit
//

#define-global commit
${root} = (with-cluster-coverage do:(warp host:<<host>> do:(solr-commit)))
${root} -> ${sink}
#end commit


//
// cluster-wide count
//  takes parameter "type":
//      "bucket": count for all records, broken down by bucket, globally
//      "partition": count for all records, broken down by partition, globally
//      "custom": requires additional parameter "field"; results are tallied as
//                a global count (which includes all replicas) of all distinct values
//                for the field specified in "field".
//

#define-global global-count
#if (!${args.type}) #set (${args.type} = "bucket") #end
#if (${args.type} == "bucket") #set ($facet_field = "bucket") #end
#if (${args.type} == "partition") #set ($facet_field = "partition") #end
#if (${args.type} == "custom") #set ($facet_field = ${args.field}) #end
#if ($facet_field)
${root} = (with-cluster-coverage host-marker:"<<${guid}-h>>" do:(warp host:<<${guid}-h>> do:(solr-select params:(facet:true facet.field:${facet_field} rows:0 q:"*:*"))))
${guid}-reducer = (value-count-reducer)
${root} -> ${guid}-reducer
${guid}-reducer -> ${sink}
#end
#end global-count




