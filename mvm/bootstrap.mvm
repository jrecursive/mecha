
// 
// register mecha.vm.bifs.* system verbs
// 

register namespace:$ module-class:mecha.vm.bifs.RiakClientModule verbs:(get:Get put:Put delete:Delete)
register namespace:$ module-class:mecha.vm.bifs.ChannelModule verbs:(subscribe:Subscribe unsubscribe:Unsubscribe publish:Publish)
register namespace:$ module-class:mecha.vm.bifs.ClientModule verbs:(client-sink:ClientSink channel-sink:ChannelSink start-all-sources:StartAllSources macro-sink:MacroSink)
register namespace:$ module-class:mecha.vm.bifs.SolrModule verbs:(solr-select:Select solr-select-iterator:SelectIterator value-count-reducer:ValueCountReducer covered-index-select:CoveredIndexSelect)
register namespace:$ module-class:mecha.vm.bifs.MDBModule verbs:(materialize-pbk-stream:MaterializePBKStream stream-partition-bucket:StreamPartitionBucket partition-bucket-iterator:PartitionBucketIterator)
register namespace:$ module-class:mecha.vm.bifs.ETLModule verbs:(project:Project extract-riak-value:ExtractRiakValue)
register namespace:$ module-class:mecha.vm.bifs.ClusterModule verbs:(with-coverage:WithCoverage with-iterated-coverage:WithIteratedCoverage with-sorted-coverage:WithSortedCoverage warp:Warp)
register namespace:$ module-class:mecha.vm.bifs.StreamModule verbs:(vector-sequencer:VectorSequencer eat:Eat limit:Limit)
register namespace:$ module-class:mecha.vm.bifs.RelationalModule verbs:(sort-merge-equijoin:SortMergeEquiJoin)
register namespace:$ module-class:mecha.vm.bifs.IteratorModule verbs:(buffered-iterator:BufferedIterator)

/////////////
// globals //
/////////////

//
// spatial-query
//

#define-global spatial-query
#if (!$args.filter) #set ($args.filter = "") #end
#if (!$args.materialize) #set ($args.materialize = "true") #end
#if (!$args.sort-field) #set ($args.sort-field = "key") #end
#if (!$args.sort-dir) #set ($args.sort-dir = "asc") #end

${root} = (with-sorted-coverage sort-field:${args.sort-field} sort-order:${args.sort-dir} partition-marker:"<<${guid}-p>>" host-marker:"<<${guid}-h>>" bucket:${args.bucket} do:(warp host:<<${guid}-h>> do:(solr-select-iterator params:(q:"partition:<<${guid}-p>> AND bucket:${args.bucket} ${args.filter}" sfield:${args.field} pt:"${args.lat},${args.lon}" d:${args.radius} fq:"{!bbox}" sort:"${args.sort-field} ${args.sort-dir}") materialize:${args.materialize})))
${root} -> ${sink}
#end spatial-query

//
// riak-materialize
//

#define-global riak-materialize
${root} = (materialize-pbk-stream)
${guid}-extractor = (extract-riak-value position:0)
${root} -> ${guid}-extractor
${guid}-extractor -> $sink
#end riak-materialize

//
// facet
//

#define-global facet
#if (!$args.filter) #set ($args.filter = "") #end
#if (!$args.mincount) #set ($args.mincount = "1") #end
#if (!$args.limit) #set ($args.limit = "100") #end
#if (!$args.start) #set ($args.start = "0") #end
${root} = (with-coverage partition-marker:"<<${guid}-p>>" host-marker:"<<${guid}-h>>" bucket:${args.bucket} do:(warp host:<<${guid}-h>> do:(solr-select params:(facet:true facet.limit:${args.limit} facet.field:${args.field} facet.mincount:${args.mincount} start:${args.start} rows:0 q:"partition:<<${guid}-p>> AND bucket:${args.bucket} ${args.filter}"))))
${guid}-reducer = (value-count-reducer)
${root} -> ${guid}-reducer
${guid}-reducer -> ${sink}
#end facet

//
// count
//

#define-global count
#if (!$args.filter) #set ($args.filter = "") #end
${root} = (with-coverage partition-marker:"<<${guid}-p>>" host-marker:"<<${guid}-h>>" bucket:${args.bucket} do:(warp host:<<${guid}-h>> do:(solr-select params:(q:"partition:<<${guid}-p>> AND bucket:${args.bucket} ${args.filter}") count-only:true)))
${guid}-reducer = (value-count-reducer)
${root} -> ${guid}-reducer
${guid}-reducer -> ${sink}
#end count

//
// query
//

#define-global query
#if (!$args.start) #set ($args.start = "0") #end
#if (!$args.count) #set ($args.count = "10") #end
#if (!$args.filter) #set ($args.filter = "") #end
#if (!$args.sort-field) #set ($args.sort-field = "key") #end
#if (!$args.sort-dir) #set ($args.sort-dir = "asc") #end
#if (!$args.materialize) #set ($args.materialize = "true") #end
#if (!$args.external-iterator) #set ($args.external-iterator = "false") #end
${root} = (with-sorted-coverage sort-field:${args.sort-field} sort-order:${args.sort-dir} partition-marker:"<<${guid}-p>>" host-marker:"<<${guid}-h>>" bucket:${args.bucket} do:(warp host:<<${guid}-h>> do:(solr-select-iterator params:(q:"*:*" fq:"partition:<<${guid}-p>> AND bucket:${args.bucket} ${args.filter}" rows:${args.count} sort:"${args.sort-field} ${args.sort-dir}") materialize:${args.materialize} external-iterator:${args.external-iterator})))
${guid}-start = (eat count:${args.start})
${guid}-limit = (limit count:${args.count})
${root} -> ${guid}-start
${guid}-start -> ${guid}-limit
${guid}-limit -> ${sink}
#end query

//
// select
//  (host-optimized version of 'query')
//

#define-global select
#*
    Setup parameter default values.
*#

#if (!$args.start) #set ($args.start = "0") #end
#if (!$args.count) #set ($args.count = "-1") #end
#if (!$args.sort-field) #set ($args.sort-field = "key") #end
#if (!$args.sort-dir) #set ($args.sort-dir = "asc") #end
#if (!$args.materialize) #set ($args.materialize = "true") #end

#*
    If a filter is specified, generate the logical AND
    connector.
*#

#if ($args.filter) 
	#set ($args.logical-connector = "AND") 
#else #set ($args.logical-connector = "") #end
#if (!$args.filter) #set ($args.filter = "") #end

#*
    Generate the chain of:
        covered-index-select do:
            warp <host> do: 
                solr-select-iterator
*#

${root} = (covered-index-select sort-field:${args.sort-field} sort-order:${args.sort-dir} query-marker:"<<${guid}-q>>" host-marker:"<<${guid}-h>>" bucket:${args.bucket} do:(warp host:<<${guid}-h>> do:(solr-select-iterator params:(q:"*:*" fq:"((<<${guid}-q>>) AND bucket:${args.bucket}) ${args.logical-connector} ${args.filter}" rows:${args.count} sort:"${args.sort-field} ${args.sort-dir}") materialize:${args.materialize})))

#*
    Account for start & count (e.g., LIMIT <start>,<count>) globally.
*#

#set ($connecting_vertex = $root)

#if ($args.start != "0")
${guid}-start = (eat count:${args.start})
${connecting_vertex} -> ${guid}-start
#set ($connecting_vertex = "${guid}-start")
#end

#if ($args.count != "-1")
${guid}-limit = (limit count:${args.count})
${connecting_vertex} -> ${guid}-limit
#set ($connecting_vertex = "${guid}-limit")
#end

${connecting_vertex} -> ${sink}
#end select

